## 数据结构

[toc]

---

### 常量

常量使用关键词`const` 定义，用于存储不会改变的数据。

存储在常量中的数据，只可以是布尔型、数字型（整型、浮点型和复数）和字符串类型。

定义常量的格式: `const identifier [type]  = value`

在go中可以省略类型说明符`[type]`，因为编译器可以通过常量的值来推断其类型。

常量的值必须是能够在编译时就能够确定的；你可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。

- 正确的做法：const c1 = 2/3
- 错误的做法：const c2 = getNumber() // 引发构建错误: getNumber() used as value

> 注意：因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：len ()。

数字型的常量是没有大小和符号的，并且可以使用任何精度而不会导致溢出。

当常量赋值给一个精度过小的数字型变量时，可能会因为无法正确表达常量所代表的数值而导致溢出，这会在编译期间就引发错误。

```go
// 常量也允许使用并行赋值的形式
const beef, two, c = "eat", 2, "veg"
const Monday, Tuesday, Wednesday, Thursday, Friday, Saturday = 1, 2, 3, 4, 5, 6
const (
    Monday, Tuesday, Wednesday = 1, 2, 3
    Thursday, Friday, Saturday = 4, 5, 6
)
```

### 变量

声明变量的一般形式是使用 `var` 关键字：`var identifier type`

```go
var a int
var b bool
var str string

// 或者
var (
    a int
    b bool
    str string
)
```

当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil。记住，所有的内存在 Go 中都是经过初始化的。

变量的命名规则遵循小驼峰命名法，即首个单词小写，每个新单词的首字母大写，例如：`numShips` 和 `startDate`。

但如果你的全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写。

一个变量（常量、类型或函数）在程序中都有一定的作用范围，称之为作用域。如果一个变量在函数体外声明，则被认为是全局变量，可以在整个包甚至外部包（被导出后）使用，不管你声明在哪个源文件里或在哪个源文件里调用该变量。在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。一般情况下，局部变量的作用域可以通过代码块（用大括号括起来的部分）判断。

变量可以编译期间就被赋值，赋值给变量使用运算符等号 =，当然你也可以在运行时对变量进行赋值操作。一般情况下，只有在两个变量类型相同时才可以互相赋值。

```go
// 初始化和赋值 可以组合起来
var identifier [type] = value
var a int = 15
var i = 5
var b bool = false
var str string = "Go says hello to the world!"
```
但是 Go 编译器的智商已经高到可以根据变量的值来自动推断其类型，这有点像 Ruby 和 Python 这类动态语言，只不过它们是在运行时进行推断，而 Go 是在编译时就已经完成推断过程。因此，你还可以使用下面的这些形式来声明及初始化变量：

```go
var a = 15
var b = false
var str = "Go says hello to the world!"

// 或者 
var (
    a = 15
    b = false
    str = "Go says hello to the world!"
    numShips = 50
    city string
)

// 变量的类型也可以在运行时实现自动推断，这种写法主要用于声明包级别的全局变量，例如：
var (
    HOME = os.Getenv("HOME")
    USER = os.Getenv("USER")
    GOROOT = os.Getenv("GOROOT")
)

// 当你在函数体内声明局部变量时，应使用简短声明语法 :=，例如
a := 1
```

下面这个例子展示了如何通过 `runtime` 包在运行时获取所在的操作系统类型，以及如何通过 `os` 包中的函数 `os.Getenv()` 来获取环境变量中的值，并保存到 `string` 类型的局部变量 `path` 中。

```go
package main

import (
    "fmt"
   "runtime"
    "os"
)

func main() {
    var goos string = runtime.GOOS
    fmt.Printf("The operating system is: %s\n", goos)
    path := os.Getenv("PATH")
    fmt.Printf("Path is %s\n", path)
}

```

#### 值类型和引用类型

程序中所用到的内存在计算机中使用一堆箱子来表示（这也是人们在讲解它的时候的画法），这些箱子被称为 “字”。根据不同的处理器以及操作系统类型，所有的字都具有 32 位（4 字节）或 64 位（8 字节）的相同长度；所有的字都使用相关的内存地址来进行表示（以十六进制数表示）。

所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值。另外，像数组和结构这些复合类型也是值类型

当使用等号 `=` 将一个变量的值赋值给另一个变量时，如：`j = i`，实际上是在内存中将 `i` 的值进行了拷贝，你可以通过 `&i` 来获取变量 `i` 的内存地址

值类型的变量的值存储在栈中。

复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。

一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。这个内存地址被称之为指针。这个指针实际上也被存在另外的某一个字中。

同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。

当使用赋值语句 `r2 = r1` 时，只有引用（地址）被复制。如果 `r1` 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，`r2` 也会受到影响。

在 Go 语言中，指针属于引用类型，其它的引用类型还包括 `slices`，`maps`和 `channel`。被引用的变量会存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间。


#### 打印

函数 `Printf` 可以在 fmt 包外部使用，这是因为它以大写字母 P 开头，该函数主要用于打印输出到控制台。通常使用的格式化字符串作为第一个参数：

```go
func Printf(format string, list of variables to be printed)bi
```

格式化字符串可以含有一个或多个的格式化标识符，例如：%..，其中 .. 可以被不同类型所对应的标识符替换，如 %s 代表字符串标识符、%v 代表使用类型的默认输出格式的标识符。这些标识符所对应的值从格式化字符串后的第一个逗号开始按照相同顺序添加，如果参数超过 1 个则同样需要使用逗号分隔。使用这些占位符可以很好地控制格式化输出的文本。

函数 fmt.Sprintf 与 Printf 的作用是完全相同的，不过前者将格式化后的字符串以返回值的形式返回给调用者，因此你可以在程序中使用包含变量的字符串

函数 fmt.Print 和 fmt.Println 会自动使用格式化标识符 %v 对字符串进行格式化，两者都会在每个参数之间自动增加空格，而后者还会在字符串的最后加上一个换行符。

#### := 赋值操作符

```go
var a = 50
// 可以简写为
a := 50
```

这种方式只可以在函数体中使用，不可以用于全局变量的声明和赋值。我们称之为初始化声明。

如果在相同的代码块中， 出现多次变量初始化申明，编译器就会提示错误`no new variables on left side of :=`

如果你声明了一个局部变量却没有在相应的代码块中使用它，编译器也会报错`a declared and not used`

但是全局变量是允许声明但不使用。

同一类型的多个变量可以声明在同一行:`var a, b, c int`

多变量可以在同一行进行赋值 `a,b,c := 5, 7, 'abc`,右边的这些值以相同的顺序赋值给左边的变量，所以 a 的值是 5， b 的值是 7，c 的值是 "abc"。这被称为 并行 或 同时 赋值。

如果你想要交换两个变量的值，则可以简单地使用 `a, b = b, a`。

空白标识符 `_` 也被用于抛弃值，如值 5 在：`_, b = 5, 7` 中被抛弃。

这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。

并行赋值也被用于当一个函数返回多个返回值时。

#### init函数

变量除了可以在全局声明中初始化，也可以在 init 函数中初始化。这是一类非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高。

每个源文件都只能包含一个 init 函数。初始化总是以单线程执行，并且按照包的依赖关系顺序执行。

一个可能的用途是在开始执行程序之前对数据进行检验或修复，以保证程序状态的正确性。

```go
// 再init中初始化Pi
package trans
import "math"
var Pi float64
func init() {
   Pi = 4 * math.Atan(1) // init() function computes Pi
}
```

init 函数也经常被用在当一个程序开始之前调用后台执行的 goroutine

```go
func init() {
   // setup preparations
   go backend()
}
```

### 字符串

字符串是 UTF-8 字符的一个序列（当字符为 ASCII 码时则占用 1 个字节，其它字符根据需要占用 2-4 个字节）。UTF-8 是被广泛使用的编码格式，是文本文件的标准编码，其它包括 XML 和 JSON 在内，也都使用该编码。由于该编码对占用字节长度的不定性，Go 中的字符串也可能根据需要占用 1 至 4 个字节。Go 这样做的好处是不仅减少了内存和硬盘空间占用，同时也不用像其它语言那样需要对使用 UTF-8 字符集的文本进行编码和解码。

字符串是一种值类型，且值不可变，即创建某个文本后你无法再次修改这个文本的内容；更深入地讲，字符串是字节的定长数组。

Go 支持以下 2 种形式的字面值：

- 解释字符串：该类字符串使用双引号括起来，其中的相关的转义字符将被替换。
    如：`\n` `\r` `\t` `\u` `\\`
- 非解释字符串：该类字符串使用反引号括起来，支持换行，例如: `` `This is a raw string \n` 中的 `\n\ `` 会被原样输出。

和 C/C++ 不一样，Go 中的字符串是根据长度限定，而非特殊字符 `\0`

`string` 类型的零值为长度为零的字符串，即空字符串 `""`。

一般的比较运算符（==、!=、<、<=、>=、>）通过在内存中按字节比较来实现字符串的对比。你可以通过函数 `len()` 来获取字符串所占的字节长度，例如：`len(str)`。

字符串的内容（纯字节）可以通过标准索引法来获取，在中括号 [] 内写入索引，索引从 0 开始计数

```go

str := "abcdefg"

// 字符串 str 的第 1 个字节
_ = str[0]

// 第三个字符
_ = str[2]

//最后一个字符
str[len(str)-1]
```

> 需要注意的是，这种转换方案只对纯 ASCII 码的字符串有效。获取字符串中某个字节的地址的行为是非法的，例如：`&str[i]`

字符串使用 `+` 拼接，例如 `s:= s1 + s2`

```go
//多行拼接
str := "Beginning of the string " +
    "second part of the string"

// +=
s := "hel" + "lo,"
s += "world!"
fmt.Println(s) //输出 “hello, world!”
```
    
在循环中使用加号 + 拼接字符串并不是最高效的做法，更好的办法是使用函数 `strings.Join()`


### 指针

Go 语言为程序员提供了控制数据结构的指针的能力；但是，你不能进行指针运算。通过给予程序员基本内存布局，Go 语言允许你控制特定集合的数据结构、分配的数量以及内存访问模式，这些对构建运行良好的系统是非常重要的：指针对于性能的影响是不言而喻的，而如果你想要做的是系统编程、操作系统或者网络应用，指针更是不可或缺的一部分。

程序在内存中存储它的值，每个内存块（或字）有一个地址，通常用十六进制数表示，如：0x6b0820 或 0xf84001d7f0。

Go 语言的取地址符是 `&`，放到一个变量前使用就会返回相应变量的内存地址。

这个地址可以存储在一个叫做指针的特殊数据类型中，如果我们想调用指针 intP，我们可以这样声明它：

```go
// 定义了一个指向int的指针
var intP *int

l1 := 'abc'
// 此时intP指向l1
intP = &l1

```

**一个指针变量可以指向任何一个值的内存地址**

 它指向那个值的内存地址，在 32 位机器上占用 4 个字节，在 64 位机器上占用 8 个字节，并且与它所指向的值的大小无关。当然，可以声明指针指向任何类型的值来表明它的原始性或结构性；你可以在指针类型前面加上 `*` 号（前缀）来获取指针所指向的内容，这里的 `*` 号是一个类型更改器。使用一个指针引用一个值被称为间接引用。当一个指针被定义后没有分配到任何变量时，它的值为 `nil`。

 一个指针变量通常缩写为 `ptr`。

> 注意：在书写表达式类似 `var p *type` 时，切记在 `*` 号和指针名称间留有一个空格，因为 `var p*type` 是语法正确的，但是在更复杂的表达式中，它容易被误认为是一个乘法表达式！

符号 `*` 可以放在一个指针前，如 `*intP`，那么它将得到这个指针指向地址上所存储的值；这被称为**反引用**（或者内容或者间接引用）操作符；另一种说法是**指针转移**。

对于任何一个变量 var， 如下表达式都是正确的：`var == *(&var)`。

```go
// 指针使用和指针反引用
package main
import "fmt"
func main() {
    var i1 = 5
    fmt.Printf("An integer: %d, its location in memory: %p\n", i1, &i1)
    var intP *int
    intP = &i1
    fmt.Printf("The value at memory location %p is %d\n", intP, *intP)
}
// An integer: 5, its location in memory: 0x24f0820
// The value at memory location 0x24f0820 is 5

// 示例2 通过对 *p 赋另一个值来更改 “对象”，这样 s 也会随之更改。
package main
import "fmt"
func main() {
    s := "good bye"
    var p *string = &s
    *p = "ciao"
    fmt.Printf("Here is the pointer p: %p\n", p) // prints address
    fmt.Printf("Here is the string *p: %s\n", *p) // prints string
    fmt.Printf("Here is the string s: %s\n", s) // prints same string
}

// Here is the pointer p: 0x2540820
// Here is the string *p: ciao
// Here is the string s: ciao
```

> 注意：你不能得到一个文字或常量的地址

所以说，Go 语言和 C、C++ 以及 D 语言这些低层（系统）语言一样，都有指针的概念。但是对于经常导致 C 语言内存泄漏继而程序崩溃的指针运算是不被允许的。Go 语言中的指针保证了内存安全，更像是 Java、C# 和 VB.NET 中的引用。因此 `c = *p++` 在 Go 语言的代码中是不合法的。

指针的一个高级应用是你可以传递一个变量的引用，这样不会传递变量的拷贝。指针传递是很廉价的，只占用 4 个或 8 个字节。当程序在工作中需要占用大量的内存，或很多变量，或者两者都有，使用指针会减少内存占用和提高效率。被指向的变量也保存在内存中，直到没有任何指针指向它们，所以从它们被创建开始就具有相互独立的生命周期。

另一方面，由于一个指针导致的间接引用，指针的过度频繁使用也会导致性能下降。指针也可以指向另一个指针，并且可以进行任意深度的嵌套，导致你可以有多级的间接引用，但在大多数情况这会使你的代码结构不清晰。

对一个空指针的反向引用是不合法的，并且会使程序崩溃：
```go
package main
func main() {
    var p *int = nil
    *p = 0
}
// in Windows: stops only with: <exit code="-1073741819" msg="process crashed"/>
// runtime error: invalid memory address or nil pointer dereference
```