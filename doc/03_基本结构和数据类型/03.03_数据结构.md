## 数据结构

[toc]

---

### 常量

常量使用关键词`const` 定义，用于存储不会改变的数据。

存储在常量中的数据，只可以是布尔型、数字型（整型、浮点型和复数）和字符串类型。

定义常量的格式: `const identifier [type]  = value`

在go中可以省略类型说明符`[type]`，因为编译器可以通过常量的值来推断其类型。

常量的值必须是能够在编译时就能够确定的；你可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。

- 正确的做法：const c1 = 2/3
- 错误的做法：const c2 = getNumber() // 引发构建错误: getNumber() used as value

> 注意：因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：len ()。

数字型的常量是没有大小和符号的，并且可以使用任何精度而不会导致溢出。

当常量赋值给一个精度过小的数字型变量时，可能会因为无法正确表达常量所代表的数值而导致溢出，这会在编译期间就引发错误。

```go
// 常量也允许使用并行赋值的形式
const beef, two, c = "eat", 2, "veg"
const Monday, Tuesday, Wednesday, Thursday, Friday, Saturday = 1, 2, 3, 4, 5, 6
const (
    Monday, Tuesday, Wednesday = 1, 2, 3
    Thursday, Friday, Saturday = 4, 5, 6
)
```

### 变量

声明变量的一般形式是使用 `var` 关键字：`var identifier type`

```go
var a int
var b bool
var str string

// 或者
var (
    a int
    b bool
    str string
)
```

当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil。记住，所有的内存在 Go 中都是经过初始化的。

变量的命名规则遵循小驼峰命名法，即首个单词小写，每个新单词的首字母大写，例如：`numShips` 和 `startDate`。

但如果你的全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写。

一个变量（常量、类型或函数）在程序中都有一定的作用范围，称之为作用域。如果一个变量在函数体外声明，则被认为是全局变量，可以在整个包甚至外部包（被导出后）使用，不管你声明在哪个源文件里或在哪个源文件里调用该变量。在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。一般情况下，局部变量的作用域可以通过代码块（用大括号括起来的部分）判断。

变量可以编译期间就被赋值，赋值给变量使用运算符等号 =，当然你也可以在运行时对变量进行赋值操作。一般情况下，只有在两个变量类型相同时才可以互相赋值。

```go
// 初始化和赋值 可以组合起来
var identifier [type] = value
var a int = 15
var i = 5
var b bool = false
var str string = "Go says hello to the world!"
```
但是 Go 编译器的智商已经高到可以根据变量的值来自动推断其类型，这有点像 Ruby 和 Python 这类动态语言，只不过它们是在运行时进行推断，而 Go 是在编译时就已经完成推断过程。因此，你还可以使用下面的这些形式来声明及初始化变量：

```go
var a = 15
var b = false
var str = "Go says hello to the world!"

// 或者 
var (
    a = 15
    b = false
    str = "Go says hello to the world!"
    numShips = 50
    city string
)

// 变量的类型也可以在运行时实现自动推断，这种写法主要用于声明包级别的全局变量，例如：
var (
    HOME = os.Getenv("HOME")
    USER = os.Getenv("USER")
    GOROOT = os.Getenv("GOROOT")
)

// 当你在函数体内声明局部变量时，应使用简短声明语法 :=，例如
a := 1
```

下面这个例子展示了如何通过 `runtime` 包在运行时获取所在的操作系统类型，以及如何通过 `os` 包中的函数 `os.Getenv()` 来获取环境变量中的值，并保存到 `string` 类型的局部变量 `path` 中。

```go
package main

import (
    "fmt"
   "runtime"
    "os"
)

func main() {
    var goos string = runtime.GOOS
    fmt.Printf("The operating system is: %s\n", goos)
    path := os.Getenv("PATH")
    fmt.Printf("Path is %s\n", path)
}

```

### 值类型和引用类型

程序中所用到的内存在计算机中使用一堆箱子来表示（这也是人们在讲解它的时候的画法），这些箱子被称为 “字”。根据不同的处理器以及操作系统类型，所有的字都具有 32 位（4 字节）或 64 位（8 字节）的相同长度；所有的字都使用相关的内存地址来进行表示（以十六进制数表示）。

所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值。另外，像数组和结构这些复合类型也是值类型

当使用等号 `=` 将一个变量的值赋值给另一个变量时，如：`j = i`，实际上是在内存中将 `i` 的值进行了拷贝，你可以通过 `&i` 来获取变量 `i` 的内存地址

值类型的变量的值存储在栈中。

复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。

一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。这个内存地址被称之为指针。这个指针实际上也被存在另外的某一个字中。

同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。

当使用赋值语句 `r2 = r1` 时，只有引用（地址）被复制。如果 `r1` 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，`r2` 也会受到影响。

在 Go 语言中，指针属于引用类型，其它的引用类型还包括 `slices`，`maps`和 `channel`。被引用的变量会存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间。


### 打印

函数 `Printf` 可以在 fmt 包外部使用，这是因为它以大写字母 P 开头，该函数主要用于打印输出到控制台。通常使用的格式化字符串作为第一个参数：

```go
func Printf(format string, list of variables to be printed)bi
```

格式化字符串可以含有一个或多个的格式化标识符，例如：%..，其中 .. 可以被不同类型所对应的标识符替换，如 %s 代表字符串标识符、%v 代表使用类型的默认输出格式的标识符。这些标识符所对应的值从格式化字符串后的第一个逗号开始按照相同顺序添加，如果参数超过 1 个则同样需要使用逗号分隔。使用这些占位符可以很好地控制格式化输出的文本。

函数 fmt.Sprintf 与 Printf 的作用是完全相同的，不过前者将格式化后的字符串以返回值的形式返回给调用者，因此你可以在程序中使用包含变量的字符串

函数 fmt.Print 和 fmt.Println 会自动使用格式化标识符 %v 对字符串进行格式化，两者都会在每个参数之间自动增加空格，而后者还会在字符串的最后加上一个换行符。

### := 赋值操作符

```go
var a = 50
// 可以简写为
a := 50
```

这种方式只可以在函数体中使用，不可以用于全局变量的声明和赋值。我们称之为初始化声明。

如果在相同的代码块中， 出现多次变量初始化申明，编译器就会提示错误`no new variables on left side of :=`

如果你声明了一个局部变量却没有在相应的代码块中使用它，编译器也会报错`a declared and not used`

但是全局变量是允许声明但不使用。

同一类型的多个变量可以声明在同一行:`var a, b, c int`

多变量可以在同一行进行赋值 `a,b,c := 5, 7, 'abc`,右边的这些值以相同的顺序赋值给左边的变量，所以 a 的值是 5， b 的值是 7，c 的值是 "abc"。这被称为 并行 或 同时 赋值。

如果你想要交换两个变量的值，则可以简单地使用 `a, b = b, a`。

空白标识符 `_` 也被用于抛弃值，如值 5 在：`_, b = 5, 7` 中被抛弃。

这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。

并行赋值也被用于当一个函数返回多个返回值时。

### init函数

变量除了可以在全局声明中初始化，也可以在 init 函数中初始化。这是一类非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高。

每个源文件都只能包含一个 init 函数。初始化总是以单线程执行，并且按照包的依赖关系顺序执行。

一个可能的用途是在开始执行程序之前对数据进行检验或修复，以保证程序状态的正确性。

```go
// 再init中初始化Pi
package trans
import "math"
var Pi float64
func init() {
   Pi = 4 * math.Atan(1) // init() function computes Pi
}
```

init 函数也经常被用在当一个程序开始之前调用后台执行的 goroutine

```go
func init() {
   // setup preparations
   go backend()
}
```