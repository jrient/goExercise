## 举例

[toc]
---

### 禁止：
- 永远不要使用形如 `var p*a` 声明变量，这会混淆指针声明和乘法运算
- 永远不要在 `for` 循环自身中改变计数器变量
- 永远不要在 `for-range` 循环中使用一个值去改变自身的值
- 永远不要将 `goto` 和前置标签一起使用
- 永远不要忘记在函数名后加括号 ()，尤其调用一个对象的方法或者使用匿名函数启动一个协程时
- 永远不要使用 `new()` 一个 map，一直使用 make
- 当为一个类型定义一个 `String ()` 方法时，不要使用 fmt.Print 或者类似的代码
- 永远不要忘记当终止缓存写入时，使用 `Flush` 函数
- 永远不要忽略错误提示，忽略错误会导致程序崩溃
- 不要使用全局变量或者共享内存，这会使并发执行的代码变得不安全
- `println` 函数仅仅是用于调试的目的
- 当切片作为参数传递时，切记不要解引用切片。

### 正确做法：
- 使用正确的方式初始化一个元素是切片的映射，例如 `map[type]slice`
- 一直使用逗号，ok 或者 checked 形式作为类型断言
- 使用一个工厂函数创建并初始化自己定义类型
- 仅当一个结构体的方法想改变结构体时，使用结构体指针作为方法的接受者，否则使用一个结构体值类型

### new() 和 make()
- 切片、映射和通道，使用 make
- 数组、结构体和所有的值类型，使用 new 

不要将值类型误用为指针
将一个值类型作为一个参数传递给函数或者作为一个方法的接收者，似乎是对内存的滥用，因为值类型一直是传递拷贝。但是另一方面，值类型的内存是在栈上分配，内存分配快速且开销不大。如果你传递一个指针，而不是一个值类型，go 编译器大多数情况下会认为需要创建一个对象，并将对象移动到堆上，所以会导致额外的内存分配：因此当使用指针代替值类型作为参数传递时，我们没有任何收获。

当且仅当代码中并发执行非常重要，才使用协程和通道。
在实际应用中，你不需要并发执行，或者你不需要关注协程和通道的开销，在大多数情况下，通过栈传递参数会更有效率。但是，如果你使用 break、return 或者 panic 去跳出一个循环，很有可能会导致内存溢出，因为协程正处理某些事情而被阻塞。在实际代码中，通常仅需写一个简单的过程式循环即可。


### 一些建议性的操作习惯

#### 不要使用布尔值

像下面代码一样，创建一个布尔型变量用于测试错误条件是多余的：

```go
var good bool
    // 测试一个错误，`good`被赋为`true`或者`false`
    if !good {
        return errors.New("things aren’t good")
    }
```

立即检测一个错误：

```go
... err1 := api.Func1()
if err1 != nil { … }
```

#### 避免错误检测使代码变得混乱

避免写出这样的代码：

```go
... err1 := api.Func1()
if err1 != nil {
    fmt.Println("err: " + err.Error())
    return
}
err2 := api.Func2()
if err2 != nil {
...
    return
}    
```

首先，包括在一个初始化的 if 语句中对函数的调用。但即使代码中到处都是以 if 语句的形式通知错误（通过打印错误信息）。通过这种方式，很难分辨什么是正常的程序逻辑，什么是错误检测或错误通知。还需注意的是，大部分代码都是致力于错误的检测。通常解决此问题的好办法是尽可能以闭包的形式封装你的错误检测，例如下面的代码：

```go
func httpRequestHandler(w http.ResponseWriter, req *http.Request) {
    err := func () error {
        if req.Method != "GET" {
            return errors.New("expected GET")
        }
        if input := parseInput(req); input != "command" {
            return errors.New("malformed command")
        }
        // 可以在此进行其他的错误检测
    } ()

        if err != nil {
            w.WriteHeader(400)
            io.WriteString(w, err)
            return
        }
        doSomething() ...
}
```
这种方法可以很容易分辨出错误检测、错误通知和正常的程序逻辑。

