## 闭包和协程的使用

---

示例 [demo3.go](./src/demo3.go)

版本 A 调用闭包 5 次打印每个索引值，版本 B 也做相同的事，但是通过协程调用每个闭包。

如果我们阻塞足够多的时间，让所有协程执行完毕，版本 B 的输出是：`4 4 4 4 4`。在版本 B 的循环中，ix 变量实际是一个单变量，表示每个数组元素的索引值。因为这些闭包都只绑定到一个变量，当你运行这段代码时，你将看见每次循环都打印最后一个索引值 4，而不是每个元素的索引值。因为协程可能在循环结束后还没有开始执行，而此时 ix 值是 4。

版本 C 的循环写法才是正确的：调用每个闭包是将 ix 作为参数传递给闭包。ix 在每次循环时都被重新赋值，并将每个协程的 ix 放置在栈中，所以当协程最终被执行时，每个索引值对协程都是可用的。